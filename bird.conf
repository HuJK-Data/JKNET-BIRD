################################################
#               Variable header                #
################################################
include "/etc/bird/vars.conf";
################################################
#                 Header end                   #
################################################
# Control Community:
#  (MY_COMMUNITY,<999, 0) Community for all my node
#  (MY_COMMUNITY,<999, 1) Community only for this node
#  (MY_COMMUNITY,   1,*)   do not send to ibgp
#  (MY_COMMUNITY,   2,*)   do not send to ebgp
#  (MY_COMMUNITY,   3,*)   do not send to kernel
#  (MY_COMMUNITY, 101,*)   allow bgp_local_perf
#  (MY_COMMUNITY, 201,*)   transit routes
#  (MY_COMMUNITY, 202,*)   peer routes
#  (MY_COMMUNITY, 203,*)   customer routes
#  (MY_COMMUNITY, 204,*)   ibgp routes

#  (MY_COMMUNITY,1000,0)   do not send to anyone
#  (MY_COMMUNITY,1001,asn) but this one
#  (MY_COMMUNITY,1002,asn) do not send to this one anyway
#  (MY_COMMUNITY,1010,0)   prepend 1 to anyone
#  (MY_COMMUNITY,1011,asn) but this one
#  (MY_COMMUNITY,1022,asn) do prepend 1 to this one anyway

# Informational Community
#  (MY_COMMUNITY,5000,country_code)
#  (MY_COMMUNITY,5001,region_code)

protocol device {
    scan time 10;
}

protocol kernel {
    scan time 20;
    learn on;
    ipv6 {
        import none;
        export filter {
            krt_prefsrc = OWNIPv6;
            if bgp_large_community ~ [(MY_COMMUNITY, 3,*)] then reject;
            kernel_route_hack();
            accept;
        };
    };
};


define bogon_prefix_v6 =  [
        ::/8+,                         # RFC 4291 IPv4-compatible, loopback, et al
        0100::/64+,                    # RFC 6666 Discard-Only
        2001:2::/48+,                  # RFC 5180 BMWG
        2001:10::/28+,                 # RFC 4843 ORCHID
        2001:db8::/32+,                # RFC 3849 documentation
        2002::/16+,                    # RFC 7526 6to4 anycast relay
        3ffe::/16+,                    # RFC 3701 old 6bone
        fc00::/7+,                     # RFC 4193 unique local unicast
        fe80::/10+,                    # RFC 4291 link local unicast
        fec0::/10+,                    # RFC 3879 old site local unicast
        ff00::/8+                      # RFC 4291 multicast
];
function is_bogon_prefix() {
    case net.type{
#        NET_IP4: return net ~ bogon_prefix_v4;
        NET_IP6: return net ~ bogon_prefix_v6;
    }
}
function is_default() {
    case net.type{
        NET_IP4: return net ~ [ 0.0.0.0/0 ];
        NET_IP6: return net ~ [ ::/0 ];
    }
}

function delete_last(int lastval){
    bgp_large_community.delete([(MY_COMMUNITY,  1, lastval),
                                (MY_COMMUNITY,  2, lastval),
                                (MY_COMMUNITY,  3, lastval),
                                (MY_COMMUNITY,101, lastval),
                                (MY_COMMUNITY,201, lastval),
                                (MY_COMMUNITY,202, lastval),
                                (MY_COMMUNITY,203, lastval),
                                (MY_COMMUNITY,204, lastval)]);
}

function bgp_import(string import_type){
    if !(import_type = "upstream" || import_type="peering" || import_type="downstream" || import_type="ibgp") then {
        print "bgp_import: invalid import_type";
        return false;
    }

    if is_bogon_prefix() || is_default() || (bgp_path.len > 100) then return false;
    if import_type = "upstream" then {
        bgp_local_pref=100;
        bgp_large_community.delete([(MY_COMMUNITY, *, *)]);
        bgp_large_community.add((MY_COMMUNITY, 201 ,0));
        return true;
    } else if import_type = "peering" then {
        bgp_local_pref=200;
        bgp_large_community.delete([(MY_COMMUNITY, * ,*)]);
        bgp_large_community.add((MY_COMMUNITY, 202 ,0));
        if 6939 ~ bgp_path then return false;
        return true;
    } else if import_type = "downstream" then {
        bgp_local_pref=300;
        bgp_large_community.delete([(MY_COMMUNITY, * ,*)]);
        bgp_large_community.add((MY_COMMUNITY, 203 ,0));
        if 6939 ~ bgp_path then return false;
        return true;
    } else if import_type = "ibgp" then {
        bgp_large_community.add((MY_COMMUNITY, 204 ,1));
        delete_last(1);
        return true;
    }
    return false;
}

function bgp_export(int peer_asn; string import_type) {
    if !(import_type = "upstream" || import_type="peering" || import_type="downstream" || import_type="ibgp") then {
        print "bgp_import: invalid import_type";
        return false;
    }
    if source = RTS_OSPF then reject;
    if import_type != "ibgp" then {
        #  (MY_COMMUNITY,1000,0)   do not send to anyone
        #  (MY_COMMUNITY,1001,asn) but this one
        #  (MY_COMMUNITY,1002,asn) do not send to this one anyway
        if (MY_COMMUNITY,1002,peer_asn) ~ bgp_large_community then {
            reject;
        } else if (MY_COMMUNITY,1000,0) ~ bgp_large_community then {
            if (MY_COMMUNITY,1001,peer_asn) !~ bgp_large_community then {
                reject;
           }
            # do not send to anyone but this one
        }
        #  (MY_COMMUNITY,1010,0)   prepend 1 to anyone
        #  (MY_COMMUNITY,1011,asn) but this one
        #  (MY_COMMUNITY,1022,asn) do prepend 1 to this one anyway
        if (MY_COMMUNITY,1012,peer_asn) ~ bgp_large_community then {
            bgp_path.prepend(OWNAS);
        } else if (MY_COMMUNITY,1010,0) ~ bgp_large_community then {
            if (MY_COMMUNITY,1011,peer_asn) !~ bgp_large_community then {
                bgp_path.prepend(OWNAS);
            }
        }
    }

    if is_bogon_prefix() || is_default() || (bgp_path.len > 100) then return false;
    bgp_local_pref=100;

    if bgp_large_community ~ [(MY_COMMUNITY,  204,*)] then bgp_path.prepend(OWNAS); # ibgp routes

    if import_type = "upstream" then {
        if bgp_large_community ~ [(MY_COMMUNITY,  201,*)] then reject; # transit
        if bgp_large_community ~ [(MY_COMMUNITY,  202,*)] then reject; # peer
        bgp_large_community.delete([(MY_COMMUNITY, *, *)]);
        if 6939 ~ bgp_path then return false;
        return true;
    } else if import_type = "peering" then {
        if bgp_large_community ~ [(MY_COMMUNITY,  201,*)] then reject; # transit
        if bgp_large_community ~ [(MY_COMMUNITY,  202,*)] then reject; # peer
        bgp_large_community.delete([(MY_COMMUNITY, * ,*)]);
        if 6939 ~ bgp_path then return false;
        return true;
    } else if import_type = "downstream" then {
        bgp_large_community.delete([(MY_COMMUNITY, * ,*)]);
        return true;
    } else if import_type = "ibgp" then {
        delete_last(1);
        return true;
    }
    return false;
};

protocol static static_bkbn {
    route OWNNETv6_bkbn unreachable;

    ipv6 {
        import filter {
            bgp_large_community.add((MY_COMMUNITY,203,0));# customer
            accept;
        };
        export none;
    };
}

protocol static static_ospf {
    route OWNNETv6_ospf unreachable;
    ipv6 {
        import filter {
            bgp_large_community.add((MY_COMMUNITY,1000,0));
            accept;
        };
        export none;
    };
}


template bgp pubebgp {
    local as OWNAS;
    path metric 1;
    interpret communities on;
    allow local as 1;

    ipv6 {
        import none;
        export none;
        import limit 10000000 action block;
    };
};

template bgp pubibgp {
    local as OWNAS;
    path metric 1;
    interpret communities on;
    allow local as 1;

    ipv6 {
        next hop self yes;
        import where bgp_import("ibgp");
        export where bgp_export(OWNAS,"ibgp");
        import limit 10000000 action block;
    };
};

include "peers/*.conf";
include "static/*.conf";
include "ospf.conf";
include "rr.conf";
