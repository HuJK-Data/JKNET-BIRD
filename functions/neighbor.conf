include "predefined.conf";

function delete_last(int lastval){
    bgp_large_community.delete([(MY_COMMUNITY,  1, lastval),
                                (MY_COMMUNITY,  2, lastval),
                                (MY_COMMUNITY,  3, lastval),
                                (MY_COMMUNITY,101, lastval),
                                (MY_COMMUNITY,201, lastval),
                                (MY_COMMUNITY,202, lastval),
                                (MY_COMMUNITY,203, lastval),
                                (MY_COMMUNITY,204, lastval)]);
}

function add_type(string peer_type){
    if !(peer_type = "upstream" || peer_type="peer" || peer_type="downstream" || peer_type="ibgp" || peer_type="grc") then {
        print "bgp_import: unknown peer_type:", peer_type;
        reject;
    }

    if peer_type = "upstream" then {
        bgp_local_pref=100;
        bgp_large_community.add((MY_COMMUNITY, 201 ,0));
    } else if peer_type = "peer" then {
        bgp_local_pref=200;
        bgp_large_community.add((MY_COMMUNITY, 202 ,0));
        if bgp_path ~ t1_asns then reject;
    } else if peer_type = "downstream" then {
        bgp_local_pref=300;
        bgp_large_community.add((MY_COMMUNITY, 203 ,0));
        if bgp_path ~ t1_asns then reject;
    } else if peer_type = "ibgp" then {
        bgp_large_community.add((MY_COMMUNITY, 204 ,1));
    } else if peer_type = "grc" then {
        reject;
    }
}

function type_filter(int peer_asn; string peer_type) {
    if !(peer_type = "upstream" || peer_type="peer" || peer_type="downstream" || peer_type="grc" || peer_type="ibgp") then {
        print "bgp_import: invalid peer_type";
        reject;
    }
    if peer_type = "upstream" then {
        if bgp_large_community ~ [(MY_COMMUNITY,  201,*)] then reject; # no transit routes
        if bgp_large_community ~ [(MY_COMMUNITY,  202,*)] then reject; # no peer routes
        if bgp_path ~ t1_asns then reject;
    } else if peer_type = "peer" then {
        if bgp_large_community ~ [(MY_COMMUNITY,  201,*)] then reject; # no transit routes
        if bgp_large_community ~ [(MY_COMMUNITY,  202,*)] then reject; # no peer routes
        if bgp_path ~ t1_asns then reject;
    } else if peer_type = "downstream" then {
        # export all routes to downstream
    } else if peer_type = "ibgp" then {
        # export all routes to ibgp
    } else if peer_type = "grc" then {
        if bgp_large_community ~ [(MY_COMMUNITY,  201,*)] then reject; # no transit routes
        if bgp_path ~ t1_asns then reject;
    }
}

function should_do_action (int action_base; int peer_asn)
int action_to_evertone;
int action_not_to_one;
int action_to_one;
{
action_to_evertone = action_base;
action_not_to_one = action_base + 1;
action_to_one = action_base + 2;
    if (MY_COMMUNITY,action_to_one,peer_asn) ~ bgp_large_community || ( (MY_COMMUNITY,action_to_evertone,0) ~ bgp_large_community && (MY_COMMUNITY,action_not_to_one,peer_asn) !~ bgp_large_community )then {
        return true;
    }
    return false;
}

function do_control_action(int peer_asn){
    # Implement (MY_COMMUNITY,100_,0)   do not send to XXX
    if should_do_action(1000,peer_asn) then {
        reject;
    }
    # Implement (MY_COMMUNITY,101_,0)   prepend 1 to XXX
    if should_do_action(1010,peer_asn) then {
        bgp_path.prepend(OWNAS);
    }
    # Implement (MY_COMMUNITY,102_,0)   prepend 2 to XXX
    if should_do_action(1020,peer_asn) then {
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
    }
    # Implement (MY_COMMUNITY,104_,0)   prepend 4 to XXX
    if should_do_action(1040,peer_asn) then {
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
    }
    # Implement (MY_COMMUNITY,108_,0)   prepend 8 to XXX
    if should_do_action(1080,peer_asn) then {
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
        bgp_path.prepend(OWNAS);
    }
}

function path_whitelist(bgppath allowed_path)
{
    if delete(bgp_path,allowed_path).len > 0 then reject;
}

function net_whitelist(prefix set allowed_prefix)
{
    return net !~ allowed_prefix;
}

function ebgp_import(string peer_type){
    if is_bogon_prefix() || is_default() || not_allowed() || (bgp_path.len > 100) then reject;
    bgp_large_community.delete([(MY_COMMUNITY, 0..999, *)]);
    add_type(peer_type);
    return true;
}

function ibgp_import(){
    add_type("ibgp");
    return true;
}

function ebgp_export(int peer_asn; string peer_type) {
    if is_bogon_prefix() || is_default() || not_allowed() || (bgp_path.len > 100) then reject;
    if source = RTS_OSPF then reject;
    type_filter(peer_asn, peer_type);
    # do_control_action(peer_asn);
    bgp_large_community.delete([(MY_COMMUNITY, 0..9999 , *)]);
    return true;
};

function ibgp_export() {
    if source = RTS_OSPF then reject;
    delete_last(1);
    if bgp_large_community !~ [(MY_COMMUNITY,  101,*)] then bgp_local_pref=100; 
    return true;
};
